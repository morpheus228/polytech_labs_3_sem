#include <cmath>			// математические функции
#include <locale.h>	// функции, устанавливающие национальные кодировки символов
#include <iostream>	// Эта - часть библиотеки STL (Standard Template Library)
#include <limits>
#include <cfloat>			// Полезные константы

using namespace std;		// Обеспечивает видимость имен STL

int n= 666;	 // Глобальная переменная. По умолчанию она обнуляется.

namespace space	 // В пространстве имен - space
{
	int n = 1;	 // Объявлена переменная n
}				 // space определяет область видимости этой переменной

void printBits(unsigned char number) {
    for (int i = 7; i >= 0; i--) {
        bool bit = (number >> i) & 1;
        std::cout << bit;
    }
    std::cout << std::endl;
}

int  main()
{
	// Выполняя программу по шагам, следите за значениями переменных  и интерпретируйте результат, объясняя себе
	// наблюдаемые значения. Обратите внимание на разную интерпретацию отладчиком  signed и unsigned типов данных.
	char c = 'A'; // 65 'A' 0x41 
	// В комментарии справа полезно проставить десятичное символьное и шестнадцатиричное 
	// значения переменной после выполнения указанной строки. Вы должны видеть их в окне Autos.
	c = 0x42;		// 66 'B' 0x42
	c = -1;		// -1 'я' 0xff
	c = CHAR_BIT;	 // Размер переменной типа char = 8 бит

	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	// wchar_t - это тип данных в языке программирования C++, который используется для представления символов Юникода.

	wchar_t cw = L'Ф';
	size_t ns = sizeof(cw); // 2 байта

	unsigned char uc = 0x41; // 65 'A' 0x41 
	uc = 'B'; // 66 'A' 0x42
	uc = -3; // 255 'я' 0xff

	int i = 1; // 1
	i = -1; //-1

	unsigned int ui = 1; // 1
	ui = -1; // 4294967295

	int s = 0xffff;	//65535
					// Здесь compiler генерирует warning. Измените код, чтобы убрать warning
					// В данном случае возникает warning, так как значение 0xffff 
					// не укладывается в диапазон значений типа short.
					// Чтобы убрать warning можзно заменить short на int
	s = short(0xffff); // -1
	s = 1; // 1

	//==== Измените код, чтобы убрать warning
	unsigned int us = 0xffff; 	// 65535
								// В данном случае возникает warning, потому что значение 0xffff не укладывается в диапазон значений знакового типа short, даже если оно присваивается беззнаковой переменной us.
	us = 5;  // 5

	 int  l = 0xffffffff; // 
							  // Чтобы избавиться от warning, можно изменить тип переменной l на тип long long:
	l = -128;

	l = FLT_MAX_EXP;	// 128: Максимальное значение экспоненты для типа float. FLT_MAX_EXP представляет максимальную допустимую экспоненту для типа float и обычно равен 128. Это значит, что максимальная допустимая экспонента для типа float составляет примерно 10^38. 
	l = DBL_MAX_EXP;    // 1024: Максимальное значение экспоненты для типа double.

	l = FLT_DIG;  // 6: Количество десятичных цифр, которые гарантированно корректно представляются и могут быть прочитаны и записаны без потери точности в типе float.
	l = DBL_DIG; // 15: Количество десятичных цифр, которые гарантированно корректно представляются и могут быть прочитаны и записаны без потери точности в типе double.

	l = FLT_MANT_DIG; // 24  Количество битов, используемых для хранения мантиссы (значащих цифр) в типе float
	l = DBL_MANT_DIG; //53 Количество битов, используемых для хранения мантиссы (значащих цифр) в типе float

	float f = -12.56f; // При объявлении переменной f типа float и присваивании ей значения -12.56, компилятор будет рассматривать это значение как значение с плавающей запятой двойной точности (double). В данном случае происходит неявное преобразование значения double в тип float, что может потенциально привести к потере точности.
	f = -1.e-27f;

	f = FLT_MAX; // 3.40282347e+38: Максимальное положительное значение, которое может быть представлено в типе float.
	f = FLT_MIN; // 1.17549435e-38: Наименьшее положительное нормализованное значение, которое может быть представлено в типе float.

	double d = 0.1234567890123456789123456789; // 0.12345678901234568
	d = -0.123456789012345e+306; // -1.2345678901234499e+305

	d = DBL_MAX; // 1.7976931348623157e+308
	d = DBL_MIN; // 2.2250738585072014e-308
	d = DBL_EPSILON; // 2.2204460492503131e-16: Самая маленькая разность между двумя переменными типа double

	uc = ~2; // Побитовое отрицание. 255 0b11111111 111111101
	i = ~0; // -1 

	// Раннее (при компиляции) или неявное приведение типов данных
	// Объясните те значения, которые вы наблюдаете в окне Autos. Определите порядок выполения присваиваний.

	// Порядок присваивания - справа налево
	d = f = i = s = c = 1 / 3; // везде нули; деляется целочисленные значения
	c = s = i = f = d = 100 / 3; // везде 33; деляется целочисленные значения
	c = s = i = f = d = 10 / 3; // везде ; деляется целочисленные значения
	c = s = i = f = d = 1 / 3.; // 0, 0, 0, 0.3333, 0.33333; делятся числа с плавающей точкой и присваются знача double и float

	// Пример "небрежного" использования неявного приведения типов.	 Объясните результаты.
	i = 256;
	c = i; // 0; При неявном приведении типов значение переменной типа int требуется уместить в переменной типа char, что приводит к потере старших битов значения. 

	uc = 255; // 255
	unsigned char u = 2, sum = uc + u; // u = 2; 2 + 255 -> перебор = 1
	

	// Явное приведение типов	Объясните разницу результатов в строках (3) и (4)
	i = 100;
	f = d = i / 3;							// (3) 33
	f = d = (double)i / 3;		// (4) 33.33333
	f = d = double(i) / 3;			// (4) 33.33333
	f = d = static_cast<double>(i) / 3;		// (4) 33.33333

	// В третей строке мы делим целочисленные значения. И результат деления приводится к такому. А после этого уже к float и double.
	// Поэтому происходит потеря значения после запятой


	// Область действия, область видимости и время существования. В этом фрагменте фигурируют четыре
	//  переменных с одним и тем же именем n.  Одна - глобальная, вторая определена в своем пространстве имен,
	// третья - локальная внутри функции main(), четвертая - локальная внутри блока. 
	//  Обратите внимание, что глобальная переменная и та, что в пространстве имен space - объявлены вне функции main()
	// Определите, к какой из четырех переменных идет обращение, cформулируйте область действия и область видимости
	// каждой переменной. Для выполнения задания рекомендуется пользоваться  закладкой "Watches" или "Locals" окна
	// "Autos". Подсказка: В окно "Watches" можно поместить сразу все переменные (n, ::n - глобальная n, и space::n)

	n = 100; // глобальная
	space::n = 200; //пространство имен
	n++; // глобальная
	int n;		//Где живет эта переменная - в функции main
	n = 10; // локальная в main
	::n++; // глобальная

	{	
		int n;		// Эта переменная живет внутри блока
		n = -1; // локальная в блоке
		n++; // локальная в блоке
		::n++; // глобальная
		space::n++; //пространство имен
	}		

	n--; // локальная в main
	::n--; // глобальная
	space::n--; //пространство имен

	// Спецификатор класса памяти - static Выполняя задание по шагам, обратите внимание на  разное поведение
	// переменных nLoc и nStat
	{
	Again:
		int outer;
		for (int i = 0; i < 5; i++)
		{
			static int nStat;
			{
				int nLoc = 0;
				nLoc++;		nStat++;
			}
			outer = nStat;
		}
		if (outer < 10)
			goto Again;
	}
	// Переменная nLoc создается на каждом шагу цикла. Переменная nStat создается один раз и сохраняет значение.


	// Перечисления - enum. Обратите внимание на явную и неявную инициализацию констант
	enum RANK
	{
		One,
		Two,
		Three,
		Four,
		Jack = 6,
		Queen,
		Ace = Queen + 3,
		Joker = 20
	};
	typedef RANK RANG;

	RANG r = Jack;
	if (r == Jack) // true
		r = Queen;

	if (r == Queen) // true
	{
		// Любой целочисленной переменной можно присвоить enum-переменную 
		int i = r; // 7
		r = RANK(i++);	// Queen	// Обратное преобразование надо указывать явно
		i = r; // 7
		r = RANK(++i); // 8
		i = r; // 8
	}
	RANK rr = Ace; // 10


	//	Логический тип bool.	Выполняя задание по шагам, следите за значениями переменной b
	{
		int n = 127;
		bool b = n != 0; // true
		b = n == 0; // false
		b = n > 0; // true
		b = n <= 0; // false
		b = n > 1; // true
b = -2;
		int num = static_cast<int>(b); // 1
		if (b)
			cout << "\n\t My flag is: true" << "   or: " << b
			<< "\n\t Conversion to int: " << num << endl;
		b = n == num; // false
		cout << "\n\t Now the flag is: false" << "   or: " << b;
	}

	//	Модификатор const
	const double pi = acos(-1.); // 3.1415926535897931
	double space_permiability = 4.e-7 * pi;		//	Магнитная проницаемость пустоты
	const int dozen = 12;
	int var = dozen;

	//	Раскомментируйте следующую строчку и объясните ошибку компиляции (l-value означает left value)
	// dozen = 1;  - ошибка возникает, потому что мы пытаемся изменить переменную const

	//	Директивы условной трансляции. Объясните значение, которое принимает переменная version.
	//	Что нужно сделать для того, чтобы результат был другим?
#define _MSVER400
	const char* version;
#if defined _MSVER400
	version = "version 4.00";
#elif defined _MSVER311
	version = "version 3.11";
#else
	version = "version Unknown";
#endif

	cout << endl << version;

	// Версия == version 4.00
	// Чтобы результат был другим можно определить _MSVER311 (#define _MSVER311 ...)

	//В окне ClassView или Solution Explorer поставьте фокус на имя проекта дайте команду Project/Properties.
	//	В диалоге Property Pages щелкните на папке Configuration Properties, убедитесь, что в разделе Code Generation
	//	установлена константа компиляции _DEBUG. Создайте директивы препроцессора и код С++, которые
	//	в зависимости от действующей конфигурации проекта (_DEBUG или NDEBUG) выводят соответствующее
	//	сообщение. Измените конфигурацию проекта (в диалоге Property Pages) и проверьте ваш код.
	//	Чтобы изменить конфигурацию пользуйтесь кнопкой Configuration Manager


	#ifdef DEBUG
		cout << endl << "DEBUG mode" << endl;
	#else
		cout << endl << "NOT DEBUG mode" << endl;
	#endif

	//	Простейшие циклы. Объясните суть происходящего. 
	{
		// Цикл while надо использовать, когда неизвестно количество итераций (повторений) цикла.
		cout << "\n\nGradually eat out all the units:\n\n";

		unsigned short us = 0xff;
		while (us) // пока us != 0 
		{
			cout << hex << us << endl; // выводим число в 16-ичном формате
			us &= us - 1; // побитовое И с присваиванием между переменной us и результатом операции us - 1.
		}
		cout << hex << us << "\nDone\n";


		// Цикл for надо использовать, когда известно количество итераций и/или есть код подготовки.
		// Подсказка: odd - нечетое, even - четное.
		cout << "\n\nShow even-odd:\n\n";
		for (int i = 0; i < 10; i++)
		{
			if (3 & 2) // 000000011 000000010 
				cout << i << " - odd\n";
			else
				cout << i << " - even\n";
		}


		// Когда нужно использовать цикл do-while?
		// Цикл do-while используется в случаях, когда нужно выполнить определенный блок кода хотя бы один раз, а затем проверять условие для продолжения выполнения цикла.
		char c = ' ';
		do
		{
			if (c == 'a')
				cout << "\nAction is a delegate type in C#";
			else if (c == 'b')
				cout << "\nbreak is one of the 'leave' statements in all C-like languages";
			else if (c == 'c')
				cout << "\ncontinue is a 'go on' statement in all C-like languages";
			else if (c == 'd')
				cout << "\ndo-while is a rarely used loop statement in all C-like languages";
			else
				cout << "\nPlease read the rules of this loop";
			cout << "\n\nEnter chars: a, b, c, d (q - to quit):\n\n";
			cin >> c;
			if (c == 'q')
				cout << "\nI am going to leave the loop\n";
		} while (c != 'q');

	}
	//	Логические условные операторы и циклы. Функция y = f(x) задана графиком
	//	Напишите фрагмент кода, который с шагом 0.1 вычисляет y = f(x)  и выводит в консольное окно значения x и y. 
	//	  y
	//	  | 
	//	 2|__________
	//	  |         /\
	//	  |        /  \
	//	  |       /    \
	//	  |______/      \__________  x
	//	  0      1   2   3
	//	 Реалируйте 2 варианта этого алгоритма:   1. Используйте операторы if	 2. Используйте тернарные операции

	double x = 0;
	double y;
	while (x <= 4) {
		if (x >= 0 && x <= 1) {
			y = 0;
		} else if (x > 1 && x <= 2) {
			y = -2 + 2*x;
		} else if (x > 2 && x <= 3) {
			y = 6 - 2*x;
		} else {
			y = 0;
		}
		cout << "x = " << x << ", y = " << y << endl;
		x += 0.1;
	}

	cout << endl;
	x = 0;
	while (x <= 4) {
    y = (x >= 0 && x <= 1) ? 0 :
        (x > 1 && x <= 2) ? -2 + 2*x:
        (x > 2 && x <= 3) ? 6 - 2*x : 0;
	cout << "x = " << x << ", y = " << y << endl;
	x += 0.1;
}


	//	Напишите фрагмент, который с помощью for и switch реализует следующую логику. Если пользователь ввел:
	//	символ 'a',   ваш алгоритм выводит  "Ok" (в кавычках)
	//	символ 'b',   ваш алгоритм выводит  Bell (alert - звуковой сигнал)
	//	символ 'с',   ваш алгоритм выводит  число, которое равно количеству введенных символов
	//	символ 'Esc', ваш алгоритм выводит  "to quit use 'q'"
	//	символ 'q',   ваш алгоритм выводит  "Bye" и выходит из цикла ввода

	char input;
    int count = 0;
	bool bol = true;

	while (bol) {
        cout << "Enter a character: ";
        cin >> input;
        count++;

        switch (input) {
            case 'a':
                cout << "Ok" << endl;
                break;
            case 'b':
                cout << "Bell" << endl;
                break;
            case 'c':
                cout << count << endl;
                break;
            case 27:
                cout << "To quit use 'q'" << endl;
                break;
            case 'q':
                cout << "Bye" << endl;
                bol = false;
				break;
            default:
                cout << "Invalid input" << endl;
                break;
        }
    }

	//	Побитовые операции:  |, &, ~, ^ и сдвиги >>, <<
	//	Поменяйте местами байты переменной flags и выведите результат в консолное окно 
	unsigned short flags = 0xaabb;
	cout <<"bits = " << hex << flags << endl;
	flags = (flags >> 8) | (flags << 8);
	cout <<"bits = " << hex << flags << endl << endl;

	//	В переменной 
    // - установите в единицу 3-й бит (счет от нуля). Выведите результат.
	unsigned char byte = 0x26; 
	printBits(byte);

	byte |= (1 << 3);
	printBits(byte);

	// - инвертируйте два младших бита. Выведите результат. 
	byte = 0x26;
	byte ^= 0x03;
	printBits(byte);

    // - обнулите 4 младших бита. Выведите результат.
	byte = 0x26;
	byte &= 0xF0;
	printBits(byte);

	cout << "\n\n";
return 0;
}